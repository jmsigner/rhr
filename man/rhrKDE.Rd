% Generated by roxygen2 (4.0.2): do not edit by hand
\name{rhrKDE}
\alias{rhrKDE}
\title{Kernel Density Estimation (KDE)}
\usage{
rhrKDE(xy, h = rhrHref(xy)$h, levels = 95,
  trast = rhrRasterFromExt(rhrExtFromPoints(xy, extendRange = 0.2), nrow =
  100, res = NULL))
}
\arguments{
  \item{xy}{Instance of \code{data.frame},
  \code{SpatialPoints}, \code{SpatialPointsDataFrame} or
  \code{RhrMappedData}. If \code{xy} is is a
  \code{data.frame}, then the first two columns are assumed
  to be the \code{x} and \code{y} coordinates of the
  relocations.}

  \item{h}{Numeric \code{vector} with the bandwidth of the
  kernel. A scalar value will be applied to both
  dimensions.}

  \item{levels}{Numeric \code{vector} indicating
  percentages at which the home range estimates should be
  evaluated.}

  \item{trast}{Instance of \code{RasterLayer} that serves
  as a template for the resulting grid of the estimation.}
}
\value{
Object of class \code{RhrKDE}
}
\description{
Function to estimate home ranges with kernel density
estimation.
}
\details{
Kernels densities are estimated with
\code{KernSmooth::bkde2d}. This is a binned approximation
of 2D kernel density estimates (see
\code{?KernSmooth::bkde2d} for more details.
}
\examples{
library(rhr)
data(datSH)

## KDE with default settings. h defaults to reference bandwidth
kde1 <- rhrKDE(datSH[, 2:3])
kde2 <- rhrKDE(datSH[, 2:3], h = rhrHpi(datSH[, 2:3])$h)
kde3 <- rhrKDE(datSH[, 2:3], h = rhrHlscv(datSH[, 2:3])$h)
kde4 <- rhrKDE(datSH[, 2:3], h = rhrHrefScaled(datSH[, 2:3])$h)

par(mfrow = c(2, 2))
plot(kde1, main = "h = ref")
plot(kde2, main = "h = plug-in-the-equation")
plot(kde3, main = "h = least-square-cross validation")
plot(kde4, main = "h = ad hoc")
}
\seealso{
\code{KernSmooth::bkde2d}, \code{rhr::rhrHref},
\code{rhr::rhrHlscv}, \code{rhr::rhrHpi}
}

